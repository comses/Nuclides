---
title: "Spatially-explicit model of cosmogenic nuclide production in sediments"
author: "Nicolas Gauthier and Nari Miller"
date: "October 20, 2016"
output:
  html_document: 
    keep_md: yes
  pdf_document:
    highlight: zenburn
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=F, warning=F}
library(tidyverse)
library(stringr)
library(rgrass7)
```

## Model specification
We use the following model for $P_z$, the production rate of $^{10}$Be at depth $z$:  
$$P_z = P_0 e^{-z\frac{\rho}{\Lambda_{spal}}} - N\lambda$$  
with parameters:  

$P_0$ is the production rate of Beryllium-10 in quartz at sea level
```{r}
P_0 <- 4.49		# [at/g/yr] after Stone, 1999.
```

$\lambda$ is the decay constant for $^{10}$Be
```{r}
ltlambda <- log(2) / 1.5e6
```

$L$ is the attenuation length for neutrons
```{r}
L <- 160 	# [g/cm2]
```  

$\rho$ is the density of overburden
```{r}
rho <- 2.6 	# [ g/cm3]
```  

and variables:

$N$ is the concentration of nuclides in the sample  
$z$ is the depth to that packet of sediment at time $t$   
$t$ is some length of time.  

### Assumptions  
For the sake of simplicity, we assume there is no topographic shielding (topographic shielding factor = 1) and a constant location in the Mediterranean at 40N 0E.


## Sample data
First we need base set of raster maps to initialize the variables.  
We create a multi-layer raster brick where each cell represents a 1 cm$^{3}$ packet of sediment, the **values()** of the cells correspond to $N$ (the concentration of nuclides in that packet), and the index of each layer corresponds to $1 + z$, the depth of that packet of sediment in cm.  

Lets create a sample raster brick with 5 layers of 1x1 cells, with an initial value of $N = 1$ for each cell.  
```{r}
N0 <- rep(1, 500)
```

## Simulation
First translate the above formula for $P_z$ into an R function that calculates the $^{10}$Be production rate given values of $N$ and $z$.
```{r}
P_z <- function(N, z){
  P_0 * exp(-z*rho/L) * exp(-ltlambda) - N*ltlambda
}
```

Numerically integrate the differential equation with Euler's method. Using this function and the sample raster brick, iterate over a period of 100 years.
```{r}
nsim <- 500 # simulation length

N <- N0 # initial conditions

record <- data_frame(time = 0, depth = 1:length(N) - .5, value = N)


for(i in 1:nsim){
  delta <- P_z(N, (1:length(N) - .5))
  N <- N + delta
  record <- data_frame(time = i, depth = 1:length(N) - .5, value = N) %>%
    bind_rows(record, .)
}
```

Plot the resulting solution.
```{r}
ggplot(record, aes(x=time, y=value, color = as.factor(depth))) + 
  geom_line() + 
  guides(color = F)
```
```{r}
ggplot(record, aes(x=value, y=depth * -1, color = as.factor(time))) + 
  geom_line() + 
  guides(color = F)
```

## Working in GRASS
Use the rgrass7 library to try doing the same thing in GRASS, using a realistic DEM.
```{r eval=FALSE, include=FALSE}
initGRASS(gisBase = "/usr/lib/grass72", home = tempdir(), 
          SG = as(rast, 'SpatialGrid'),
          remove_GISRC = T, override = T)
```

```{r}
coor <- c(725763.609242,4284801.3547)

elev_init <- 'DEM'
bedrock <- 'bedrock'
init <- 1 # inital nuclide value

nsim <- 50

expr <- paste0(c('soildepth_init = if(', elev_init, ' - ', bedrock, ' < 0, 0, ', elev_init, ' - ', bedrock, ')'), collapse = '')
execGRASS('r.mapcalc', flags = c('overwrite'), expression = expr)
```


```{r}
init_depths <- readRAST('soildepth_init') %>% # pull in raster from grass as spatial grid data frame
  as_tibble %>% # convert to tibble
  mutate(depth_cm = as.integer(soildepth_init * 100)) %>% # convert depths from m to cm, then to integers
  mutate(soil_column = map(depth_cm, ~ rep.int(init, .x))) # make columns of length depth with value init value
  
init_depths

new <- init_depths %>% 
  mutate(soil_column = map_if(soil_column, ~ length(.x) > 0, function(x) imap_dbl(x, ~ .x + P_z(.x, z = (.y - .5)))))
```


```{r}
elevmaps <- execGRASS('g.list', flags = c('m'), type='rast', pattern='levol_elevation*', separator=',', intern = T) %>%
  str_split(',', simplify = T)

edmaps <- execGRASS('g.list', flags = c('m'), type='rast', pattern='levol_ED_rate*', separator=',', intern = T) %>%
  str_split(',', simplify = T)
edmaps.bare <- execGRASS('g.list', flags = c('m'), type='rast', pattern='levol_bare_ED_rate*', separator=',', intern = T) %>%
  str_split(',', simplify = T)
edmaps.forest <- execGRASS('g.list', flags = c('m'), type='rast', pattern='levol_forest_ED_rate*', separator=',', intern = T) %>%
  str_split(',', simplify = T)

# loop thru simulation outputs, generating the local watershed from each elevation map, add together into a master watershed 
for(i in 1:nsim){
  execGRASS('r.watershed', flags = c('quiet', 'overwrite'), elevation = elevmaps[i], drainage = 'fldr_tmp')
  execGRASS('r.water.outlet', flags = c('quiet', 'overwrite'), input = 'fldr_tmp', output = paste0('basin_tmp_', i), coordinates = coor)
}

basinmaps <- execGRASS('g.list', flags = c('m'), type = 'rast', pattern = 'basin_tmp_*', separator = ',', intern = T) %>%
  str_split(',', simplify = T)



execGRASS('r.mapcalc', flags = c('overwrite'), expression = 'basin_tmp = if(isnull(basin_tmp), 0, 1)')


#execGRASS('r.mask', raster = 'basin_tmp', flags = c('overwrite'))

execGRASS('r.series', flags = c('overwrite'), input = edmaps, output = 'erosion_total', method = 'sum')
#readRAST('erosion_total') %>% plot

mask <- readRAST('basin_tmp') %>% as_tibble
left_join(init_depths, mask)$basin_tmp %>% sum


#sample the erosion and deposition maps at core coordinats, convert to centimeters, aggregate to ten year periods
execGRASS('r.what', map = edmaps.forest, coordinates = coor, separator = ',', intern = T) %>%
  str_split(',', simplify = T) %>%
  .[,-(1:3)] %>%
  as.numeric %>%
  `*`(100) %>%
  data_frame(val = ., interval = rep(1:10, each = 10)) %>%
  group_by(interval) %>%
  summarise(val = sum(val))


execGRASS('r.mask', flags = c('r'))


readRAST('erosion_total') %>% as_tibble %>%
  ggplot(aes(s1,s2, fill = erosion_total)) +
  geom_raster() +
  scale_fill_distiller(type = 'div', limits = c(-.1,.1)) +
  geom_point(x = coor[1], y = coor[2]) +
  coord_equal()
```
back to desolve integration
```{r}
library(deSolve)
library(phaseR)

be10 <- function(t, y, parameters){
    z <- parameters
    dy <- P_0 * exp(-z*L/p) - y*ltlambda
    list(dy)
} 


## Chaos in the atmosphere
Lorenz <- function(t, state, parameters) {
  with(as.list(c(state, parameters)), {
    dX <-  a * X + Y * Z
    dY <-  b * (Y - Z)
    dZ <- -X * Y + c * Y - Z
    list(c(dX, dY, dZ))
  })
}

parameters <- c(a = -8/3, b = -10, c = 28)
state      <- c(X = 1, Y = 1, Z = 1)
times      <- seq(0, 100, by = 0.01)

out <- ode(y = state, times = times, func = Lorenz, parms = parameters)

plot(out)

## add a 3D figure if package scatterplot3D is available
if (require(scatterplot3d))
  scatterplot3d(out[,-1], type = "l")
```


need to work on the z() command
no, actually just use a tibble in r to store the stratigraphy

extra grass commands
need to find the top and bottom values of the dem and set them as the t and b bounds in the 3d region first
g.region t=1305 b=540 res=10 tbres=.1                                           


r.to.rast3elev -l --overwrite input=nuclide_init@PERMANENT elevation=DEM output=nuclide_3d
make a 3d raster from a dem and a data, filling under bounds


Run r.watershed to calculate drainage direction map.
```{r}
doGRASS('r.watershed', flags = c('overwrite'), elevation = dem, drainage = dir) 
```


Select a point

for each time step:
  if erosion rate is positive:
    subtract that depth from nuclide profile
  if deposition rate is positive:
    get drainage direction map
    calculate watershed at that point using r.water.outlet
    get all the cells in that watershed
    add up the nucldie enrichment of all the cells that eroded in the watershed, average based on the depth of erosion
    add that value of nuclide in the depth of deposition  at that area.

                             

r.water.outlet --overwrite input=draindir_45@PERMANENT output=basin_temp coordinates=724673.750147,4284260.05826